From: Talat Batheesh <talatb@mellanox.com>
Subject: [PATCH] BACKPORT: drivers/infiniband/core/ucm.c

Change-Id: I0e021aff0f061aa3af924494b80b31b8a7811815
---
 drivers/infiniband/core/ucm.c | 107 ++++++++++++++++++++++++++++++++++++++----
 1 file changed, 99 insertions(+), 8 deletions(-)

diff --git a/drivers/infiniband/core/ucm.c b/drivers/infiniband/core/ucm.c
index xxxxxxx..xxxxxxx 100644
--- a/drivers/infiniband/core/ucm.c
+++ b/drivers/infiniband/core/ucm.c
@@ -46,7 +46,9 @@
 #include <linux/mutex.h>
 #include <linux/slab.h>
 
+#ifdef HAVE_ARRAY_INDEX_NOSPEC
 #include <linux/nospec.h>
+#endif
 
 #include <linux/uaccess.h>
 
@@ -60,6 +62,9 @@
 MODULE_AUTHOR("Libor Michalek");
 MODULE_DESCRIPTION("InfiniBand userspace Connection Manager access");
 MODULE_LICENSE("Dual BSD/GPL");
+#ifdef RETPOLINE_MLNX
+MODULE_INFO(retpoline, "Y");
+#endif
 
 struct ib_ucm_device {
 	int			devnum;
@@ -124,14 +129,18 @@ static struct ib_client ucm_client = {
 	.add    = ib_ucm_add_one,
 	.remove = ib_ucm_remove_one
 };
-
+#ifdef HAVE_XARRAY
 static DEFINE_XARRAY_ALLOC(ctx_id_table);
+#else
+static DEFINE_MUTEX(ctx_id_mutex);
+static DEFINE_IDR(ctx_id_table);
+#endif
 static DECLARE_BITMAP(dev_map, IB_UCM_MAX_DEVICES);
 
 static struct ib_ucm_context *ib_ucm_ctx_get(struct ib_ucm_file *file, int id)
 {
 	struct ib_ucm_context *ctx;
-
+#ifdef HAVE_XARRAY
 	xa_lock(&ctx_id_table);
 	ctx = xa_load(&ctx_id_table, id);
 	if (!ctx)
@@ -141,7 +150,17 @@ static struct ib_ucm_context *ib_ucm_ctx_get(struct ib_ucm_file *file, int id)
 	else
 		atomic_inc(&ctx->ref);
 	xa_unlock(&ctx_id_table);
-
+#else
+	mutex_lock(&ctx_id_mutex);
+	ctx = idr_find(&ctx_id_table, id);
+	if (!ctx)
+		ctx = ERR_PTR(-ENOENT);
+	else if (ctx->file != file)
+		ctx = ERR_PTR(-EINVAL);
+	else
+		atomic_inc(&ctx->ref);
+	mutex_unlock(&ctx_id_mutex);
+#endif
 	return ctx;
 }
 
@@ -183,6 +202,9 @@ static void ib_ucm_cleanup_events(struct ib_ucm_context *ctx)
 static struct ib_ucm_context *ib_ucm_ctx_alloc(struct ib_ucm_file *file)
 {
 	struct ib_ucm_context *ctx;
+#ifndef HAVE_IDR_ALLOC
+	int result;
+#endif
 
 	ctx = kzalloc(sizeof *ctx, GFP_KERNEL);
 	if (!ctx)
@@ -192,10 +214,29 @@ static struct ib_ucm_context *ib_ucm_ctx_alloc(struct ib_ucm_file *file)
 	init_completion(&ctx->comp);
 	ctx->file = file;
 	INIT_LIST_HEAD(&ctx->events);
-
+#ifdef HAVE_XARRAY
 	if (xa_alloc(&ctx_id_table, &ctx->id, ctx, xa_limit_32b, GFP_KERNEL))
 		goto error;
+#elif HAVE_IDR_ALLOC
+ 	mutex_lock(&ctx_id_mutex);
+ 	ctx->id = idr_alloc(&ctx_id_table, ctx, 0, 0, GFP_KERNEL);
+ 	mutex_unlock(&ctx_id_mutex);
+ 	if (ctx->id < 0)
+ 		goto error;
+#else
+	do {
+		result = idr_pre_get(&ctx_id_table, GFP_KERNEL);
+		if (!result)
+			goto error;
+
+		mutex_lock(&ctx_id_mutex);
+		result = idr_get_new(&ctx_id_table, ctx, &ctx->id);
+		mutex_unlock(&ctx_id_mutex);
+	} while (result == -EAGAIN);
 
+	if (result)
+		goto error;
+#endif
 	list_add_tail(&ctx->file_list, &file->ctxs);
 	return ctx;
 
@@ -510,7 +551,13 @@ static ssize_t ib_ucm_create_id(struct ib_ucm_file *file,
 err2:
 	ib_destroy_cm_id(ctx->cm_id);
 err1:
+#ifdef HAVE_XARRAY
 	xa_erase(&ctx_id_table, ctx->id);
+#else
+	mutex_lock(&ctx_id_mutex);
+	idr_remove(&ctx_id_table, ctx->id);
+	mutex_unlock(&ctx_id_mutex);
+#endif
 	kfree(ctx);
 	return result;
 }
@@ -529,7 +576,7 @@ static ssize_t ib_ucm_destroy_id(struct ib_ucm_file *file,
 
 	if (copy_from_user(&cmd, inbuf, sizeof(cmd)))
 		return -EFAULT;
-
+#ifdef HAVE_XARRAY
 	xa_lock(&ctx_id_table);
 	ctx = xa_load(&ctx_id_table, cmd.id);
 	if (!ctx)
@@ -539,7 +586,17 @@ static ssize_t ib_ucm_destroy_id(struct ib_ucm_file *file,
 	else
 		__xa_erase(&ctx_id_table, ctx->id);
 	xa_unlock(&ctx_id_table);
-
+#else
+	mutex_lock(&ctx_id_mutex);
+	ctx = idr_find(&ctx_id_table, cmd.id);
+	if (!ctx)
+		ctx = ERR_PTR(-ENOENT);
+	else if (ctx->file != file)
+		ctx = ERR_PTR(-EINVAL);
+	else
+		idr_remove(&ctx_id_table, ctx->id);
+	mutex_unlock(&ctx_id_mutex);
+#endif
 	if (IS_ERR(ctx))
 		return PTR_ERR(ctx);
 
@@ -1112,8 +1169,9 @@ static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,
 
 	if (hdr.cmd >= ARRAY_SIZE(ucm_cmd_table))
 		return -EINVAL;
+#ifdef HAVE_ARRAY_INDEX_NOSPEC
 	hdr.cmd = array_index_nospec(hdr.cmd, ARRAY_SIZE(ucm_cmd_table));
-
+#endif
 	if (hdr.in + sizeof(hdr) > len)
 		return -EINVAL;
 
@@ -1165,7 +1223,11 @@ static int ib_ucm_open(struct inode *inode, struct file *filp)
 	file->filp = filp;
 	file->device = container_of(inode->i_cdev, struct ib_ucm_device, cdev);
 
+#ifdef HAVE_STREAM_OPEN
 	return stream_open(inode, filp);
+#else
+	return nonseekable_open(inode, filp);
+#endif
 }
 
 static int ib_ucm_close(struct inode *inode, struct file *filp)
@@ -1178,8 +1240,13 @@ static int ib_ucm_close(struct inode *inode, struct file *filp)
 		ctx = list_entry(file->ctxs.next,
 				 struct ib_ucm_context, file_list);
 		mutex_unlock(&file->file_mutex);
-
+#ifdef HAVE_XARRAY
 		xa_erase(&ctx_id_table, ctx->id);
+#else
+		mutex_lock(&ctx_id_mutex);
+		idr_remove(&ctx_id_table, ctx->id);
+		mutex_unlock(&ctx_id_mutex);
+#endif
 		ib_destroy_cm_id(ctx->cm_id);
 		ib_ucm_cleanup_events(ctx);
 		kfree(ctx);
@@ -1289,8 +1356,16 @@ static void ib_ucm_remove_one(struct ib_device *device, void *client_data)
 	put_device(&ucm_dev->dev);
 }
 
+#ifdef HAVE_CLASS_ATTR_STRING
 static CLASS_ATTR_STRING(abi_version, S_IRUGO,
 			 __stringify(IB_USER_CM_ABI_VERSION));
+#else
+static ssize_t show_abi_version(struct class *class, char *buf)
+{
+	return sprintf(buf, "%d\n", IB_USER_CM_ABI_VERSION);
+}
+static CLASS_ATTR(abi_version, S_IRUGO, show_abi_version, NULL);
+#endif
 
 static int __init ib_ucm_init(void)
 {
@@ -1310,7 +1385,11 @@ static int __init ib_ucm_init(void)
 		goto err_alloc;
 	}
 
+#ifdef HAVE_CLASS_ATTR_STRING
 	ret = class_create_file(&cm_class, &class_attr_abi_version.attr);
+#else
+	ret = class_create_file(&cm_class, &class_attr_abi_version);
+#endif
 	if (ret) {
 		pr_err("ucm: couldn't create abi_version attribute\n");
 		goto error2;
@@ -1324,7 +1403,11 @@ static int __init ib_ucm_init(void)
 	return 0;
 
 error3:
+#ifdef HAVE_CLASS_ATTR_STRING
 	class_remove_file(&cm_class, &class_attr_abi_version.attr);
+#else
+	class_remove_file(&cm_class, &class_attr_abi_version);
+#endif
 error2:
 	unregister_chrdev_region(dynamic_ucm_dev, IB_UCM_NUM_DYNAMIC_MINOR);
 err_alloc:
@@ -1336,10 +1419,18 @@ error1:
 static void __exit ib_ucm_cleanup(void)
 {
 	ib_unregister_client(&ucm_client);
+#ifdef HAVE_CLASS_ATTR_STRING
 	class_remove_file(&cm_class, &class_attr_abi_version.attr);
+#else
+	class_remove_file(&cm_class, &class_attr_abi_version);
+#endif
 	unregister_chrdev_region(IB_UCM_BASE_DEV, IB_UCM_NUM_FIXED_MINOR);
 	unregister_chrdev_region(dynamic_ucm_dev, IB_UCM_NUM_DYNAMIC_MINOR);
+#ifdef HAVE_XARRAY
 	WARN_ON(!xa_empty(&ctx_id_table));
+#else
+	idr_destroy(&ctx_id_table);
+#endif
 }
 
 module_init(ib_ucm_init);
