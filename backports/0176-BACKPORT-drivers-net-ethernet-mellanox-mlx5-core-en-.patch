From: Talat Batheesh <talatb@mellanox.com>
Subject: [PATCH] BACKPORT: drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c

Change-Id: Ifc7cb27a48a57f19f3d9a84401e657350654e8a5
---
 .../net/ethernet/mellanox/mlx5/core/en/tc_tun.c    | 49 +++++++++++++++++++---
 1 file changed, 43 insertions(+), 6 deletions(-)

diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
index xxxxxxx..xxxxxxx 100644
--- a/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
+++ b/drivers/net/ethernet/mellanox/mlx5/core/en/tc_tun.c
@@ -38,7 +38,11 @@ static int get_route_and_out_devs(struct mlx5e_priv *priv,
 	/* if the egress device isn't on the same HW e-switch or
 	 * it's a LAG device, use the uplink
 	 */
+#ifdef HAVE_NETDEV_PORT_SAME_PARENT_ID
 	if (!netdev_port_same_parent_id(priv->netdev, real_dev) ||
+#else
+	if (!switchdev_port_same_parent_id(priv->netdev, real_dev) ||
+#endif
 	    dst_is_lag_dev) {
 		*route_dev = dev;
 		*out_dev = uplink_dev;
@@ -86,8 +90,11 @@ static int mlx5e_route_lookup_ipv4(struct mlx5e_priv *priv,
 	ret = PTR_ERR_OR_ZERO(rt);
 	if (ret)
 		return ret;
-
+#ifdef HAVE_RT_GW_FAMILY
 	if (mlx5_lag_is_multipath(mdev) && rt->rt_gw_family != AF_INET)
+#else
+	if (mlx5_lag_is_multipath(mdev) && rt->rt_uses_gateway)
+#endif
 		return -ENETUNREACH;
 #else
 	return -EOPNOTSUPP;
@@ -533,9 +540,15 @@ static int mlx5e_tc_tun_parse_vxlan(struct mlx5e_priv *priv,
 				    struct mlx5_flow_spec *spec,
 				    struct tc_cls_flower_offload *f,
 				    void *headers_c,
-				    void *headers_v)
+				    void *headers_v
+#ifndef HAVE_TC_SETUP_FLOW_ACTION
+				    , struct flow_rule *rule
+#endif
+						   )
 {
+#ifdef HAVE_TC_SETUP_FLOW_ACTION
 	struct flow_rule *rule = tc_cls_flower_offload_flow_rule(f);
+#endif
 	struct netlink_ext_ack *extack = f->common.extack;
 	void *misc_c = MLX5_ADDR_OF(fte_match_param,
 				    spec->match_criteria,
@@ -599,13 +612,19 @@ static int mlx5e_tc_tun_parse_gretap(struct mlx5e_priv *priv,
 				     struct mlx5_flow_spec *spec,
 				     struct tc_cls_flower_offload *f,
 				     void *outer_headers_c,
-				     void *outer_headers_v)
+				     void *outer_headers_v
+#ifndef HAVE_TC_SETUP_FLOW_ACTION
+				     , struct flow_rule *rule
+#endif
+							  )
 {
 	void *misc_c = MLX5_ADDR_OF(fte_match_param, spec->match_criteria,
 				    misc_parameters);
 	void *misc_v = MLX5_ADDR_OF(fte_match_param, spec->match_value,
 				    misc_parameters);
+#ifdef HAVE_TC_SETUP_FLOW_ACTION
 	struct flow_rule *rule = tc_cls_flower_offload_flow_rule(f);
+#endif
 
 	if (!MLX5_CAP_ESW(priv->mdev, nvgre_encap_decap)) {
 		NL_SET_ERR_MSG_MOD(f->common.extack,
@@ -641,20 +660,38 @@ int mlx5e_tc_tun_parse(struct net_device *filter_dev,
 		       struct mlx5_flow_spec *spec,
 		       struct tc_cls_flower_offload *f,
 		       void *headers_c,
-		       void *headers_v, u8 *match_level)
+		       void *headers_v, u8 *match_level
+#ifndef HAVE_TC_SETUP_FLOW_ACTION
+		       , struct flow_rule *rule
+#endif
+						       )
 {
 	int tunnel_type;
 	int err = 0;
 
+#ifdef HAVE_TC_BLOCK_OFFLOAD
+/* in old kernels with egdev we don't pass the netdev so the filter_dev here
+ * is actually priv->netdev. we only assume and support vxlan */
+	tunnel_type = MLX5E_TC_TUNNEL_TYPE_VXLAN;
+#else
 	tunnel_type = mlx5e_tc_tun_get_type(filter_dev);
+#endif
 	if (tunnel_type == MLX5E_TC_TUNNEL_TYPE_VXLAN) {
 		*match_level = MLX5_MATCH_L4;
 		err = mlx5e_tc_tun_parse_vxlan(priv, spec, f,
-					       headers_c, headers_v);
+					       headers_c, headers_v
+#ifndef HAVE_TC_SETUP_FLOW_ACTION
+					       , rule
+#endif
+								   );
 	} else if (tunnel_type == MLX5E_TC_TUNNEL_TYPE_GRETAP) {
 		*match_level = MLX5_MATCH_L3;
 		err = mlx5e_tc_tun_parse_gretap(priv, spec, f,
-						headers_c, headers_v);
+						headers_c, headers_v
+#ifndef HAVE_TC_SETUP_FLOW_ACTION
+					        , rule
+#endif
+						      );
 	} else {
 		netdev_warn(priv->netdev,
 			    "decapsulation offload is not supported for %s (kind: \"%s\")\n",
