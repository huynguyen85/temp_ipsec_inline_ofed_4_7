From: Talat Batheesh <talatb@mellanox.com>
Subject: [PATCH] BACKPORT: drivers/infiniband/core/restrack.c

Change-Id: I2afdcd243906616208272ef9d27396f236ffbcfc
---
 drivers/infiniband/core/restrack.c | 84 +++++++++++++++++++++++++++++++++++++-
 1 file changed, 83 insertions(+), 1 deletion(-)

diff --git a/drivers/infiniband/core/restrack.c b/drivers/infiniband/core/restrack.c
index xxxxxxx..xxxxxxx 100644
--- a/drivers/infiniband/core/restrack.c
+++ b/drivers/infiniband/core/restrack.c
@@ -31,8 +31,12 @@ int rdma_restrack_init(struct ib_device *dev)
 
 	rt = dev->res;
 
+#ifdef HAVE_XARRAY
 	for (i = 0; i < RDMA_RESTRACK_MAX; i++)
 		xa_init_flags(&rt[i].xa, XA_FLAGS_ALLOC);
+#else
+	init_rwsem(&rt->rwsem);
+#endif
 
 	return 0;
 }
@@ -58,11 +62,17 @@ static const char *type2str(enum rdma_restrack_type type)
  */
 void rdma_restrack_clean(struct ib_device *dev)
 {
+#ifdef HAVE_XARRAY
 	struct rdma_restrack_root *rt = dev->res;
+#else
+	struct rdma_restrack_root *res = dev->res;
+#endif
 	struct rdma_restrack_entry *e;
 	char buf[TASK_COMM_LEN];
-	bool found = false;
 	const char *owner;
+	COMPAT_HL_NODE;
+#ifdef HAVE_XARRAY
+	bool found = false;
 	int i;
 
 	for (i = 0 ; i < RDMA_RESTRACK_MAX; i++) {
@@ -101,6 +111,37 @@ void rdma_restrack_clean(struct ib_device *dev)
 		pr_err("restrack: %s", CUT_HERE);
 
 	kfree(rt);
+#else
+
+	int bkt;
+
+	if (hash_empty(res->hash)) {
+		kfree(res);
+		return;
+	}
+
+	pr_err("restrack: %s", CUT_HERE);
+	dev_err(&dev->dev, "BUG: RESTRACK detected leak of resources\n");
+	compat_hash_for_each(res->hash, bkt, e, node) {
+		if (rdma_is_kernel_res(e)) {
+			owner = e->kern_name;
+		} else {
+			/*
+			 * There is no need to call get_task_struct here,
+			 * because we can be here only if there are more
+			 * get_task_struct() call than put_task_struct().
+			 */
+			get_task_comm(buf, e->task);
+			owner = buf;
+		}
+
+		pr_err("restrack: %s %s object allocated by %s is not freed\n",
+		       rdma_is_kernel_res(e) ? "Kernel" : "User",
+		       type2str(e->type), owner);
+	}
+	pr_err("restrack: %s", CUT_HERE);
+	kfree(res);
+#endif /* HAVE_XARRAY */
 }
 
 /**
@@ -112,6 +153,7 @@ void rdma_restrack_clean(struct ib_device *dev)
 int rdma_restrack_count(struct ib_device *dev, enum rdma_restrack_type type,
 			struct pid_namespace *ns)
 {
+#ifdef HAVE_XARRAY
 	struct rdma_restrack_root *rt = &dev->res[type];
 	struct rdma_restrack_entry *e;
 	XA_STATE(xas, &rt->xa, 0);
@@ -126,6 +168,26 @@ int rdma_restrack_count(struct ib_device *dev, enum rdma_restrack_type type,
 	}
 	xa_unlock(&rt->xa);
 	return cnt;
+#else
+	struct rdma_restrack_root *res = dev->res;
+	struct rdma_restrack_entry *e;
+	u32 cnt = 0;
+	COMPAT_HL_NODE
+
+	down_read(&res->rwsem);
+#ifdef HAVE_HLIST_FOR_EACH_ENTRY_3_PARAMS
+	hash_for_each_possible(res->hash, e, node, type) {
+#else
+	hash_for_each_possible(res->hash, e, hlnode, node, type) {
+#endif
+		if (ns == &init_pid_ns ||
+		    (!rdma_is_kernel_res(e) &&
+		     ns == task_active_pid_ns(e->task)))
+			cnt++;
+	}
+	up_read(&res->rwsem);
+	return cnt;
+#endif /* HAVE_XARRAY */
 }
 EXPORT_SYMBOL(rdma_restrack_count);
 
@@ -211,16 +273,21 @@ void rdma_restrack_attach_task(struct rdma_restrack_entry *res,
 static void rdma_restrack_add(struct rdma_restrack_entry *res)
 {
 	struct ib_device *dev = res_to_dev(res);
+#ifdef HAVE_XARRAY
 	struct rdma_restrack_root *rt;
+#endif
 	int ret;
 
 	if (!dev)
 		return;
 
+#ifdef HAVE_XARRAY
 	rt = &dev->res[res->type];
+#endif
 
 	kref_init(&res->kref);
 	init_completion(&res->comp);
+#ifdef HAVE_XARRAY
 	if (res->type == RDMA_RESTRACK_QP) {
 		/* Special case to ensure that LQPN points to right QP */
 		struct ib_qp *qp = container_of(res, struct ib_qp, res);
@@ -241,6 +308,12 @@ static void rdma_restrack_add(struct rdma_restrack_entry *res)
 
 	if (!ret)
 		res->valid = true;
+#else
+	res->valid = true;
+	down_write(&dev->res->rwsem);
+	hash_add(dev->res->hash, &res->node, res->type);
+	up_write(&dev->res->rwsem);
+#endif
 }
 
 /**
@@ -333,15 +406,24 @@ void rdma_restrack_del(struct rdma_restrack_entry *res)
 	if (WARN_ON(!dev))
 		return;
 
+#ifdef HAVE_XARRAY
 	rt = &dev->res[res->type];
 
 	old = xa_erase(&rt->xa, res->id);
 	WARN_ON(old != res);
 	res->valid = false;
 
+#endif
 	rdma_restrack_put(res);
 	wait_for_completion(&res->comp);
 
+#ifndef HAVE_XARRAY
+	down_write(&dev->res->rwsem);
+	hash_del(&res->node);
+	res->valid = false;
+	up_write(&dev->res->rwsem);
+#endif
+
 out:
 	if (res->task) {
 		put_task_struct(res->task);
